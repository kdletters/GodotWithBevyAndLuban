/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/

pub mod prelude {
    pub use crate::card::*;
    pub use crate::*;
}

#[derive(Debug)]
pub enum LubanError {
    Loader(String),
    Table(String),
    Bean(String),
    Polymorphic(String),
    Unknown(String),
}

impl std::fmt::Display for LubanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(match self {
            LubanError::Loader(msg)
            | LubanError::Table(msg)
            | LubanError::Bean(msg)
            | LubanError::Polymorphic(msg)
            | LubanError::Unknown(msg) => msg,
        })
    }
}

pub struct Tables {
    pub Tbtranslate: std::sync::Arc<crate::Tbtranslate>,
    pub TbCardsInfo: std::sync::Arc<crate::card::TbCardsInfo>,
    pub TbSiteItems: std::sync::Arc<crate::card::TbSiteItems>,
}

impl Tables {
    pub fn new<T: Fn(&str) -> Result<ByteBuf, LubanError>>(
        loader: T,
    ) -> Result<Tables, LubanError> {
        let mut tables = Tables {
            Tbtranslate: crate::Tbtranslate::new(loader("tbtranslate")?)?,
            TbCardsInfo: crate::card::TbCardsInfo::new(loader("card_tbcardsinfo")?)?,
            TbSiteItems: crate::card::TbSiteItems::new(loader("card_tbsiteitems")?)?,
        };
        unsafe {
            tables.resolve_ref();
        }
        Ok(tables)
    }

    unsafe fn resolve_ref(&mut self) {
        let mut b = Box::from_raw(
            self.Tbtranslate.as_ref() as *const crate::Tbtranslate as *mut crate::Tbtranslate
        );
        b.as_mut().resolve_ref(self);
        let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbCardsInfo.as_ref() as *const crate::card::TbCardsInfo
            as *mut crate::card::TbCardsInfo);
        b.as_mut().resolve_ref(self);
        let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbSiteItems.as_ref() as *const crate::card::TbSiteItems
            as *mut crate::card::TbSiteItems);
        b.as_mut().resolve_ref(self);
        let _ = Box::into_raw(b);
    }
}
pub mod card;

use luban_lib::*;

#[derive(Debug)]
pub struct translate {
    pub key: String,
    pub cn: String,
}

impl translate {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<translate, LubanError> {
        let key = buf.read_string();
        let cn = buf.read_string();

        Ok(translate { key, cn })
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {}

    pub const __ID__: i32 = 1052832078;
}

#[derive(Debug)]
pub struct vector2 {
    pub x: f32,
    pub y: f32,
}

impl vector2 {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<vector2, LubanError> {
        let x = buf.read_float();
        let y = buf.read_float();

        Ok(vector2 { x, y })
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {}

    pub const __ID__: i32 = 337790799;
}

#[derive(Debug)]
pub struct vector3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl vector3 {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<vector3, LubanError> {
        let x = buf.read_float();
        let y = buf.read_float();
        let z = buf.read_float();

        Ok(vector3 { x, y, z })
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {}

    pub const __ID__: i32 = 337790800;
}

#[derive(Debug)]
pub struct vector4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}

impl vector4 {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<vector4, LubanError> {
        let x = buf.read_float();
        let y = buf.read_float();
        let z = buf.read_float();
        let w = buf.read_float();

        Ok(vector4 { x, y, z, w })
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {}

    pub const __ID__: i32 = 337790801;
}

#[derive(Debug)]
pub struct Tbtranslate {
    pub data_list: Vec<std::sync::Arc<crate::translate>>,
    pub data_map: std::collections::HashMap<String, std::sync::Arc<crate::translate>>,
}

impl Tbtranslate {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<Tbtranslate>, LubanError> {
        let mut data_map: std::collections::HashMap<String, std::sync::Arc<crate::translate>> =
            Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::translate>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::translate::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.key.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(Tbtranslate {
            data_map,
            data_list,
        }))
    }

    pub fn get(&self, key: &str) -> Option<std::sync::Arc<crate::translate>> {
        self.data_map.get(key).map(|x| x.clone())
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
            let mut b =
                Box::from_raw(x.as_ref() as *const crate::translate as *mut crate::translate);
            b.as_mut().resolve_ref(tables);
            let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<String> for Tbtranslate {
    type Output = std::sync::Arc<crate::translate>;

    fn index(&self, index: String) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}
