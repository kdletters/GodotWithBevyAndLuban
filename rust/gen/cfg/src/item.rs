
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/


use super::*;
use luban_lib::*;

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EQuality {
    ///最差品质
    WHITE = 1,
    ///蓝色的
    BLUE = 2,
    ///紫色的
    PURPLE = 3,
    ///最高品质
    RED = 4,
}

impl From<i32> for EQuality {
    fn from(value: i32) -> Self {
        match value {
            1 => EQuality::WHITE,
            2 => EQuality::BLUE,
            3 => EQuality::PURPLE,
            4 => EQuality::RED,
            _ => panic!("Invalid value for EQuality:{}", value),
        }
    }
}

#[derive(Debug)]
pub struct Item {
    /// 这是id
    pub id: i32,
    /// 名字
    pub name: String,
    /// 描述
    pub desc: String,
    /// 价格
    pub price: i32,
    /// 引用当前表
    pub upgrade_to_item_id: i32,
    pub upgrade_to_item_id_ref: Option<std::sync::Arc<crate::item::Item>>,
    /// 过期时间
    pub expire_time: Option<u64>,
    /// 能否批量使用
    pub batch_useable: bool,
    /// 品质
    pub quality: crate::item::EQuality,
    /// 道具兑换配置
    pub exchange_stream: crate::item::ItemExchange,
    pub exchange_list: Vec<crate::item::ItemExchange>,
    /// 道具兑换配置
    pub exchange_column: crate::item::ItemExchange,
}

impl Item{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Item, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        let desc = buf.read_string();
        let price = buf.read_int();
        let upgrade_to_item_id = buf.read_int();
        let upgrade_to_item_id_ref = None;
        let mut expire_time = if buf.read_bool() { Some(buf.read_ulong()) } else { None };
        let batch_useable = buf.read_bool();
        let quality = buf.read_int().into();
        let exchange_stream = crate::item::ItemExchange::new(&mut buf)?;
        let exchange_list = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::item::ItemExchange::new(&mut buf)?); } _e0 };
        let exchange_column = crate::item::ItemExchange::new(&mut buf)?;
        
        Ok(Item { id, name, desc, price, upgrade_to_item_id, upgrade_to_item_id_ref, expire_time, batch_useable, quality, exchange_stream, exchange_list, exchange_column, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.upgrade_to_item_id_ref = tables.TbItem.get(&self.upgrade_to_item_id);
        self.exchange_stream.resolve_ref(tables);
        self.exchange_list.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.exchange_column.resolve_ref(tables);
    }

    pub const __ID__: i32 = 2107285806;
}

#[derive(Debug)]
pub struct ItemExchange {
    /// 道具id
    pub id: i32,
    /// 道具数量
    pub num: i32,
}

impl ItemExchange{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<ItemExchange, LubanError> {
        let id = buf.read_int();
        let num = buf.read_int();
        
        Ok(ItemExchange { id, num, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 1814660465;
}


#[derive(Debug)]
pub struct TbItem {
    pub data_list: Vec<std::sync::Arc<crate::item::Item>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::item::Item>>,
}

impl TbItem {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbItem>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::item::Item>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::item::Item>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::item::Item::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbItem { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::item::Item>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::item::Item as *mut crate::item::Item); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbItem {
    type Output = std::sync::Arc<crate::item::Item>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


