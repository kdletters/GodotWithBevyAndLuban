/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/

use super::*;
use luban_lib::*;

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum CardClass {
    ///物品
    Item = 0,
    ///矿物
    Ore = 1,
}

impl From<i32> for CardClass {
    fn from(value: i32) -> Self {
        match value {
            0 => CardClass::Item,
            1 => CardClass::Ore,
            _ => panic!("Invalid value for CardClass:{}", value),
        }
    }
}

#[derive(Debug)]
pub struct CardsInfo {
    pub base_cardName: String,
    pub index: i32,
    /// 展示名称
    pub base_displayName: String,
    /// 展示描述
    pub base_description: String,
    /// 图标
    pub base_icon: String,
    /// 卡片类型
    pub base_cardClass: crate::card::CardClass,
    pub base_price: i32,
    pub base_cardWeight: i32,
    pub base_maxStack: i32,
    pub site_area: i32,
    pub npc_schedule: i32,
    pub food_HP: i32,
}

impl CardsInfo {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<CardsInfo, LubanError> {
        let base_cardName = buf.read_string();
        let index = buf.read_int();
        let base_displayName = buf.read_string();
        let base_description = buf.read_string();
        let base_icon = buf.read_string();
        let base_cardClass = buf.read_int().into();
        let base_price = buf.read_int();
        let base_cardWeight = buf.read_int();
        let base_maxStack = buf.read_int();
        let site_area = buf.read_int();
        let npc_schedule = buf.read_int();
        let food_HP = buf.read_int();

        Ok(CardsInfo {
            base_cardName,
            index,
            base_displayName,
            base_description,
            base_icon,
            base_cardClass,
            base_price,
            base_cardWeight,
            base_maxStack,
            site_area,
            npc_schedule,
            food_HP,
        })
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {}

    pub const __ID__: i32 = -1645498061;
}

#[derive(Debug)]
pub struct SiteItems {
    pub base_cardName: String,
    pub weight: i32,
}

impl SiteItems {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<SiteItems, LubanError> {
        let base_cardName = buf.read_string();
        let weight = buf.read_int();

        Ok(SiteItems {
            base_cardName,
            weight,
        })
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {}

    pub const __ID__: i32 = -1971263685;
}

#[derive(Debug)]
pub struct TbCardsInfo {
    pub data_list: Vec<std::sync::Arc<crate::card::CardsInfo>>,
    pub data_map: std::collections::HashMap<String, std::sync::Arc<crate::card::CardsInfo>>,
}

impl TbCardsInfo {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbCardsInfo>, LubanError> {
        let mut data_map: std::collections::HashMap<
            String,
            std::sync::Arc<crate::card::CardsInfo>,
        > = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::card::CardsInfo>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::card::CardsInfo::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.base_cardName.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbCardsInfo {
            data_map,
            data_list,
        }))
    }

    pub fn get(&self, key: &str) -> Option<std::sync::Arc<crate::card::CardsInfo>> {
        self.data_map.get(key).map(|x| x.clone())
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
            let mut b = Box::from_raw(
                x.as_ref() as *const crate::card::CardsInfo as *mut crate::card::CardsInfo
            );
            b.as_mut().resolve_ref(tables);
            let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<String> for TbCardsInfo {
    type Output = std::sync::Arc<crate::card::CardsInfo>;

    fn index(&self, index: String) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}

#[derive(Debug)]
pub struct TbSiteItems {
    pub data_list: Vec<std::sync::Arc<crate::card::SiteItems>>,
    pub data_map: std::collections::HashMap<String, std::sync::Arc<crate::card::SiteItems>>,
}

impl TbSiteItems {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbSiteItems>, LubanError> {
        let mut data_map: std::collections::HashMap<
            String,
            std::sync::Arc<crate::card::SiteItems>,
        > = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::card::SiteItems>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::card::SiteItems::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.base_cardName.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbSiteItems {
            data_map,
            data_list,
        }))
    }

    pub fn get(&self, key: &str) -> Option<std::sync::Arc<crate::card::SiteItems>> {
        self.data_map.get(key).map(|x| x.clone())
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
            let mut b = Box::from_raw(
                x.as_ref() as *const crate::card::SiteItems as *mut crate::card::SiteItems
            );
            b.as_mut().resolve_ref(tables);
            let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<String> for TbSiteItems {
    type Output = std::sync::Arc<crate::card::SiteItems>;

    fn index(&self, index: String) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}
